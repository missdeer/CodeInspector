diff --git a/include/SciLexer.h b/include/SciLexer.h
index 618534fa..78d8345e 100644
--- a/include/SciLexer.h
+++ b/include/SciLexer.h
@@ -146,6 +146,10 @@
 #define SCLEX_RAKU 131
 #define SCLEX_FSHARP 132
 #define SCLEX_JULIA 133
+#define SCLEX_LLVM 209
+#define SCLEX_KOTLIN 210
+#define SCLEX_WASM 213
+#define SCLEX_SWIFT 218
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -2000,6 +2004,100 @@
 #define SCE_FSHARP_QUOTATION 17
 #define SCE_FSHARP_ATTRIBUTE 18
 #define SCE_FSHARP_FORMAT_SPEC 19
+#define SCE_KOTLIN_DEFAULT 0
+#define SCE_KOTLIN_COMMENTLINE 1
+#define SCE_KOTLIN_COMMENTLINEDOC 2
+#define SCE_KOTLIN_COMMENTBLOCK 3
+#define SCE_KOTLIN_COMMENTBLOCKDOC 4
+#define SCE_KOTLIN_COMMENTDOCWORD 5
+#define SCE_KOTLIN_TASKMARKER 6
+#define SCE_KOTLIN_NUMBER 7
+#define SCE_KOTLIN_OPERATOR 8
+#define SCE_KOTLIN_OPERATOR2 9
+#define SCE_KOTLIN_CHARACTER 10
+#define SCE_KOTLIN_STRING 11
+#define SCE_KOTLIN_RAWSTRING 12
+#define SCE_KOTLIN_ESCAPECHAR 13
+#define SCE_KOTLIN_RAWSTRINGSTART 14
+#define SCE_KOTLIN_RAWSTRINGEND 15
+#define SCE_KOTLIN_BACKTICKS 16
+#define SCE_KOTLIN_VARIABLE 17
+#define SCE_KOTLIN_ANNOTATION 18
+#define SCE_KOTLIN_LABEL 19
+#define SCE_KOTLIN_IDENTIFIER 20
+#define SCE_KOTLIN_WORD 21
+#define SCE_KOTLIN_CLASS 22
+#define SCE_KOTLIN_INTERFACE 23
+#define SCE_KOTLIN_ENUM 24
+#define SCE_KOTLIN_FUNCTION 25
+#define SCE_LLVM_DEFAULT 0
+#define SCE_LLVM_COMMENTLINE 1
+#define SCE_LLVM_TASKMARKER 2
+#define SCE_LLVM_NUMBER 3
+#define SCE_LLVM_IDENTIFIER 4
+#define SCE_LLVM_OPERATOR 5
+#define SCE_LLVM_STRING 6
+#define SCE_LLVM_ESCAPECHAR 7
+#define SCE_LLVM_COMDAT 8
+#define SCE_LLVM_METADATA 9
+#define SCE_LLVM_META_STRING 10
+#define SCE_LLVM_ATTRIBUTE_GROUP 11
+#define SCE_LLVM_VARIABLE 12
+#define SCE_LLVM_GLOBAL_VARIABLE 13
+#define SCE_LLVM_QUOTED_VARIABLE 14
+#define SCE_LLVM_QUOTED_GLOBAL_VARIABLE 15
+#define SCE_LLVM_ATTRIBUTE 16
+#define SCE_LLVM_INSTRUCTION 17
+#define SCE_LLVM_INTRINSIC 18
+#define SCE_LLVM_FUNCTION 19
+#define SCE_LLVM_WORD 20
+#define SCE_LLVM_WORD2 21
+#define SCE_LLVM_TYPE 22
+#define SCE_LLVM_LABEL 23
+#define SCE_WASM_DEFAULT 0
+#define SCE_WASM_COMMENTLINE 1
+#define SCE_WASM_COMMENTBLOCK 2
+#define SCE_WASM_TASKMARKER 3
+#define SCE_WASM_NUMBER 4
+#define SCE_WASM_OPERATOR 5
+#define SCE_WASM_IDENTIFIER 6
+#define SCE_WASM_STRING 7
+#define SCE_WASM_ESCAPECHAR 8
+#define SCE_WASM_INSTRUCTION 9
+#define SCE_WASM_WORD 10
+#define SCE_WASM_KEYWORD 11
+#define SCE_WASM_TYPE 12
+#define SCE_SWIFT_DEFAULT 0
+#define SCE_SWIFT_COMMENTLINE 1
+#define SCE_SWIFT_COMMENTLINEDOC 2
+#define SCE_SWIFT_COMMENTBLOCK 3
+#define SCE_SWIFT_COMMENTBLOCKDOC 4
+#define SCE_SWIFT_TASKMARKER 5
+#define SCE_SWIFT_NUMBER 6
+#define SCE_SWIFT_OPERATOR 7
+#define SCE_SWIFT_OPERATOR2 8
+#define SCE_SWIFT_FUNCTION 9
+#define SCE_SWIFT_LABEL 10
+#define SCE_SWIFT_STRING 11
+#define SCE_SWIFT_TRIPLE_STRING 12
+#define SCE_SWIFT_STRING_ED 13
+#define SCE_SWIFT_TRIPLE_STRING_ED 14
+#define SCE_SWIFT_ESCAPECHAR 15
+#define SCE_SWIFT_TRIPLE_STRINGSTART 16
+#define SCE_SWIFT_TRIPLE_STRING_EDSTART 17
+#define SCE_SWIFT_TRIPLE_STRINGEND 18
+#define SCE_SWIFT_TRIPLE_STRING_EDEND 19
+#define SCE_SWIFT_DIRECTIVE 20
+#define SCE_SWIFT_IDENTIFIER 21
+#define SCE_SWIFT_IDENTIFIER_BT 22
+#define SCE_SWIFT_ATTRIBUTE 23
+#define SCE_SWIFT_VARIABLE 24
+#define SCE_SWIFT_WORD 25
+#define SCE_SWIFT_CLASS 26
+#define SCE_SWIFT_STRUCT 27
+#define SCE_SWIFT_PROTOCOL 28
+#define SCE_SWIFT_ENUM 29
+#define SCE_SWIFT_FUNCTION_DEFINE 30
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff --git a/lexers/LexA68k.cxx b/lexers/LexA68k.cxx
index eb22ca10..b5a78635 100644
--- a/lexers/LexA68k.cxx
+++ b/lexers/LexA68k.cxx
@@ -34,31 +34,6 @@ using namespace Lexilla;
 #define OPERATOR_1CHAR  1
 #define OPERATOR_2CHAR  2
 
-
-/**
- *  IsIdentifierStart
- *
- *  Return true if the given char is a valid identifier first char
- */
-
-static inline bool IsIdentifierStart (const int ch)
-{
-    return (isalpha(ch) || (ch == '_') || (ch == '\\'));
-}
-
-
-/**
- *  IsIdentifierChar
- *
- *  Return true if the given char is a valid identifier char
- */
-
-static inline bool IsIdentifierChar (const int ch)
-{
-    return (isalnum(ch) || (ch == '_') || (ch == '@') || (ch == ':') || (ch == '.'));
-}
-
-
 /**
  *  GetOperatorType
  *
diff --git a/lexers/LexBasic.cxx b/lexers/LexBasic.cxx
index 7839271a..2995651a 100644
--- a/lexers/LexBasic.cxx
+++ b/lexers/LexBasic.cxx
@@ -79,10 +79,6 @@ static bool IsDigit(int c) {
 	return c < 128 && (character_classification[c] & 8);
 }
 
-static bool IsHexDigit(int c) {
-	return c < 128 && (character_classification[c] & 16);
-}
-
 static bool IsBinDigit(int c) {
 	return c < 128 && (character_classification[c] & 32);
 }
diff --git a/lexers/LexHollywood.cxx b/lexers/LexHollywood.cxx
index 2cf22d6d..e6760df9 100644
--- a/lexers/LexHollywood.cxx
+++ b/lexers/LexHollywood.cxx
@@ -197,10 +197,6 @@ static bool IsDigit(int c) {
 	return c < 128 && (character_classification[c] & 8);
 }
 
-static bool IsHexDigit(int c) {
-	return c < 128 && (character_classification[c] & 16);
-}
-
 static int LowerCase(int c)
 {
 	if (c >= 'A' && c <= 'Z')
diff --git a/lexers/LexMagik.cxx b/lexers/LexMagik.cxx
index 3fda8f16..a9a2b5bf 100644
--- a/lexers/LexMagik.cxx
+++ b/lexers/LexMagik.cxx
@@ -36,16 +36,6 @@ static inline bool IsAlphaCore(int ch) {
     return (isalpha(ch) || ch == '!' || ch == '?');
 }
 
-/**
- * Is it a character (IsAlphaCore() and underscore)
- *
- * \param  ch The character
- * \return True if ch is a character, False otherwise
- */
-static inline bool IsAlpha(int ch) {
-    return (IsAlphaCore(ch) || ch == '_');
-}
-
 /**
  * Is it a symbolic character (IsAlpha() and colon)
  *
diff --git a/lexers/LexOScript.cxx b/lexers/LexOScript.cxx
index 98c6b23a..92bee5f9 100644
--- a/lexers/LexOScript.cxx
+++ b/lexers/LexOScript.cxx
@@ -31,24 +31,6 @@ using namespace Lexilla;
 // -----------------------------------------
 // Functions classifying a single character.
 
-// This function is generic and should be probably moved to CharSet.h where
-// IsAlphaNumeric the others reside.
-inline bool IsAlpha(int ch) {
-	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
-}
-
-static inline bool IsIdentifierChar(int ch) {
-	// Identifiers cannot contain non-ASCII letters; a word with non-English
-	// language-specific characters cannot be an identifier.
-	return IsAlphaNumeric(ch) || ch == '_';
-}
-
-static inline bool IsIdentifierStart(int ch) {
-	// Identifiers cannot contain non-ASCII letters; a word with non-English
-	// language-specific characters cannot be an identifier.
-	return IsAlpha(ch) || ch == '_';
-}
-
 static inline bool IsNumberChar(int ch, int chNext) {
 	// Numeric constructs are not checked for lexical correctness. They are
 	// expected to look like +1.23-E9 but actually any bunch of the following
diff --git a/lexers/LexR.cxx b/lexers/LexR.cxx
index 8f2849a1..b1f75be2 100644
--- a/lexers/LexR.cxx
+++ b/lexers/LexR.cxx
@@ -12,6 +12,7 @@
 #include <stdarg.h>
 #include <assert.h>
 #include <ctype.h>
+#include <algorithm>
 
 #include "ILexer.h"
 #include "Scintilla.h"
@@ -210,5 +211,64 @@ static const char * const RWordLists[] = {
         };
 
 
+constexpr int GetLineCommentState(int lineState) noexcept {
+	return lineState & SimpleLineStateMaskLineComment;
+}
+
+namespace Lexilla {
+
+void FoldSimpleDoc(Sci_PositionU startPos, Sci_Position lengthDoc, int /*initStyle*/, LexerWordList /*keywordLists*/, Accessor &styler) {
+	const Sci_PositionU endPos = startPos + lengthDoc;
+	auto lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	int lineCommentPrev = 0;
+	if (lineCurrent > 0) {
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+		lineCommentPrev = GetLineCommentState(styler.GetLineState(lineCurrent - 1));
+	}
+
+	int levelNext = levelCurrent;
+	int lineCommentCurrent = GetLineCommentState(styler.GetLineState(lineCurrent));
+	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
+	Sci_PositionU lineEndPos = std::min(lineStartNext, endPos) - 1;
+
+	for (Sci_PositionU i = startPos; i < endPos; i++) {
+		const int style = styler.StyleAt(i);
+
+		if (style == SCE_SIMPLE_OPERATOR) {
+			const char ch = styler[i];
+			if (ch == '{' || ch == '[' || ch == '(') {
+				levelNext++;
+			} else if (ch == '}' || ch == ']' || ch == ')') {
+				levelNext--;
+			}
+		}
+
+		if (i == lineEndPos) {
+			const int lineCommentNext = GetLineCommentState(styler.GetLineState(lineCurrent + 1));
+			if (lineCommentCurrent) {
+				levelNext += lineCommentNext - lineCommentPrev;
+			}
+
+			const int levelUse = levelCurrent;
+			int lev = levelUse | levelNext << 16;
+			if (levelUse < levelNext) {
+				lev |= SC_FOLDLEVELHEADERFLAG;
+			}
+			if (lev != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, lev);
+			}
+
+			lineCurrent++;
+			lineStartNext = styler.LineStart(lineCurrent + 1);
+			lineEndPos = std::min(lineStartNext, endPos) - 1;
+			levelCurrent = levelNext;
+			lineCommentPrev = lineCommentCurrent;
+			lineCommentCurrent = lineCommentNext;
+		}
+	}
+}
+
+}
 
 LexerModule lmR(SCLEX_R, ColouriseRDoc, "r", FoldRDoc, RWordLists);
diff --git a/lexers/LexRust.cxx b/lexers/LexRust.cxx
index 5b359556..87935fc2 100644
--- a/lexers/LexRust.cxx
+++ b/lexers/LexRust.cxx
@@ -183,11 +183,6 @@ static bool IsWhitespace(int c) {
     return c == ' ' || c == '\t' || c == '\r' || c == '\n';
 }
 
-/* This isn't quite right for Unicode identifiers */
-static bool IsIdentifierStart(int ch) {
-	return (IsASCII(ch) && (isalpha(ch) || ch == '_')) || !IsASCII(ch);
-}
-
 /* This isn't quite right for Unicode identifiers */
 static bool IsIdentifierContinue(int ch) {
 	return (IsASCII(ch) && (isalnum(ch) || ch == '_')) || !IsASCII(ch);
diff --git a/lexlib/CharacterSet.h b/lexlib/CharacterSet.h
index 50eedb7c..134e213a 100644
--- a/lexlib/CharacterSet.h
+++ b/lexlib/CharacterSet.h
@@ -65,8 +65,30 @@ public:
 
 using CharacterSet = CharacterSetArray<0x80>;
 
+template <typename T, typename... Args>
+constexpr bool AnyOf(T t, Args... args) noexcept {
+#if defined(__clang__)
+	static_assert(__is_integral(T));
+#endif
+	return ((t == args) || ...);
+}
+
+// prevent pointer without <type_traits>
+template <typename T, typename... Args>
+constexpr void AnyOf([[maybe_unused]] T *t, [[maybe_unused]] Args... args) noexcept {}
+template <typename T, typename... Args>
+constexpr void AnyOf([[maybe_unused]] const T *t, [[maybe_unused]] Args... args) noexcept {}
+
+constexpr bool Between(int value, int lower, int high) noexcept {
+	return value >= lower && value <= high;
+}
+
 // Functions for classifying characters
 
+constexpr bool IsEOLChar(int ch) noexcept {
+	return ch == '\r' || ch == '\n';
+}
+
 constexpr bool IsASpace(int ch) noexcept {
     return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
 }
@@ -76,17 +98,43 @@ constexpr bool IsASpaceOrTab(int ch) noexcept {
 }
 
 constexpr bool IsADigit(int ch) noexcept {
-	return (ch >= '0') && (ch <= '9');
+	return ch >= '0' && ch <= '9';
+}
+
+constexpr bool IsHexDigit(int ch) noexcept {
+	return (ch >= '0' && ch <= '9')
+		|| (ch >= 'A' && ch <= 'F')
+		|| (ch >= 'a' && ch <= 'f');
+}
+
+constexpr bool IsOctalDigit(int ch) noexcept {
+	return ch >= '0' && ch <= '7';
 }
 
 constexpr bool IsADigit(int ch, int base) noexcept {
 	if (base <= 10) {
-		return (ch >= '0') && (ch < '0' + base);
-	} else {
-		return ((ch >= '0') && (ch <= '9')) ||
-		       ((ch >= 'A') && (ch < 'A' + base - 10)) ||
-		       ((ch >= 'a') && (ch < 'a' + base - 10));
+		return (ch >= '0' && ch < '0' + base);
 	}
+	return (ch >= '0' && ch <= '9')
+		|| Between(ch | 0x20, 'a', 'a' + base - 10);
+}
+
+constexpr bool IsNumberStart(int ch, int chNext) noexcept {
+	return IsADigit(ch) || (ch == '.' && IsADigit(chNext));
+}
+
+constexpr bool IsNumberStartEx(int chPrev, int ch, int chNext) noexcept {
+	return IsADigit(ch) || (chPrev != '.' && ch == '.' && IsADigit(chNext));
+}
+
+constexpr bool IsNumberContinue(int chPrev, int ch, int chNext) noexcept {
+	return ((ch == '+' || ch == '-') && (chPrev == 'e' || chPrev == 'E'))
+		|| (ch == '.' && chNext != '.');
+}
+
+constexpr bool IsNumberContinueEx(int chPrev, int ch, int chNext) noexcept {
+	return ((ch == '+' || ch == '-') && (chPrev == 'e' || chPrev == 'E' || chPrev == 'p' || chPrev == 'P'))
+		|| (ch == '.' && chNext != '.');
 }
 
 constexpr bool IsASCII(int ch) noexcept {
@@ -105,6 +153,11 @@ constexpr bool IsUpperOrLowerCase(int ch) noexcept {
 	return IsUpperCase(ch) || IsLowerCase(ch);
 }
 
+constexpr bool IsAlpha(int ch) noexcept {
+	return (ch >= 'a' && ch <= 'z')
+		|| (ch >= 'A' && ch <= 'Z');
+}
+
 constexpr bool IsAlphaNumeric(int ch) noexcept {
 	return
 		((ch >= '0') && (ch <= '9')) ||
@@ -128,6 +181,34 @@ constexpr bool iswordstart(int ch) noexcept {
 	return IsAlphaNumeric(ch) || ch == '_';
 }
 
+constexpr bool IsIdentifierChar(int ch) noexcept {
+	return IsAlphaNumeric(ch) || ch == '_';
+}
+
+constexpr bool IsIdentifierStart(int ch) noexcept {
+	return IsAlpha(ch) || ch == '_';
+}
+
+constexpr bool IsDecimalNumber(int chPrev, int ch, int chNext) noexcept {
+	return IsIdentifierChar(ch) || IsNumberContinue(chPrev, ch, chNext);
+}
+
+constexpr bool IsDecimalNumberEx(int chPrev, int ch, int chNext) noexcept {
+	return IsIdentifierChar(ch) || IsNumberContinueEx(chPrev, ch, chNext);
+}
+
+// simply treat every character/byte larger than 127 as Unicode identifier,
+// i.e. we don't support Unicode operators. proper implementation will need
+// enable multiByteAccess in StyleContext and use functions from CharacterCategory.
+
+constexpr bool IsIdentifierCharEx(int ch) noexcept {
+	return IsIdentifierChar(ch) || ch >= 0x80;
+}
+
+constexpr bool IsIdentifierStartEx(int ch) noexcept {
+	return IsIdentifierStart(ch) || ch >= 0x80;
+}
+
 constexpr bool isoperator(int ch) noexcept {
 	if (IsAlphaNumeric(ch))
 		return false;
@@ -140,6 +221,45 @@ constexpr bool isoperator(int ch) noexcept {
 		return true;
 	return false;
 }
+// isoperator() excludes following eight punctuation: '"', '#', '$', '\'', '@', '\\', '_', '`'
+// in most lexers, isoperator(ch) is equivalent to following code:
+// IsAGraphic(ch) && !AnyOf(ch, '#', '$', '@', '\\', '`');
+
+constexpr bool IsAGraphic(int ch) noexcept {
+	// excludes C0 control characters and whitespace
+	return ch > 32 && ch < 127;
+}
+
+constexpr bool IsGraphic(int ch) noexcept {
+	// excludes C0 control characters and whitespace
+	return ch > 32 && ch != 127;
+}
+
+constexpr bool IsPunctuation(int ch) noexcept {
+	//return IsAGraphic(ch) && !IsAlphaNumeric(ch);
+	return (ch > 32 && ch < '0')
+		|| (ch > '9' && ch < 'A')
+		|| (ch > 'Z' && ch < 'a')
+		|| (ch > 'z' && ch < 127);
+}
+
+constexpr bool IsCommentTagPrev(int chPrev) noexcept {
+	return chPrev <= 32 || AnyOf(chPrev, '/', '*', '!');
+}
+
+constexpr bool IsInvalidUrlChar(int ch) noexcept {
+	return ch <= 32 || ch >= 127
+		|| AnyOf(ch, '"', '<', '>', '\\', '^', '`', '{', '|', '}');
+}
+
+// characters can follow jump `label:`, based on Swift's document Labeled Statement at
+// https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_labeled-statement
+// good coding style should place left aligned label on it's own line.
+constexpr bool IsJumpLabelNextChar(int chNext) noexcept {
+	// own line, comment, for, foreach, while, do, if, switch, repeat
+	// TODO: match each word exactly like HighlightTaskMarker().
+	return AnyOf(chNext, '\0', '/', 'f', 'w', 'd', 'i', 's', 'r');
+}
 
 // Simple case functions for ASCII supersets.
 
diff --git a/lexlib/LexAccessor.h b/lexlib/LexAccessor.h
index 331c501f..675b5d7c 100644
--- a/lexlib/LexAccessor.h
+++ b/lexlib/LexAccessor.h
@@ -8,6 +8,11 @@
 #ifndef LEXACCESSOR_H
 #define LEXACCESSOR_H
 
+#include <algorithm>
+#include "StringUtils.h"
+#include "CharacterSet.h"
+#include "LexerUtils.h"
+
 namespace Lexilla {
 
 enum class EncodingType { eightBit, unicode, dbcs };
@@ -181,6 +186,23 @@ public:
 	void ChangeLexerState(Sci_Position start, Sci_Position end) {
 		pAccess->ChangeLexerState(start, end);
 	}
+
+	
+	void GetRange(Sci_PositionU startPos_, Sci_PositionU endPos_, char *s, Sci_PositionU len) noexcept {
+		endPos_ = std::min(endPos_, startPos_ + len - 1);
+		if (startPos_ >= static_cast<Sci_PositionU>(startPos) && endPos_ <= static_cast<Sci_PositionU>(endPos)) {
+			const char *p = buf + (startPos_ - startPos);
+			const char * const t = buf + (endPos_ - startPos);
+			while (p < t) {
+				*s++ = *p++;
+			}
+		} else {
+			for (; startPos_ < endPos_; startPos_++) {
+				*s++ = (*this)[startPos_];
+			}
+		}
+		*s = '\0';
+	}
 };
 
 struct LexicalClass {
@@ -190,6 +212,181 @@ struct LexicalClass {
 	const char *description;
 };
 
+constexpr bool IsWhiteSpace(int ch) noexcept {
+	return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
+}
+
+inline unsigned char LexGetNextChar(Sci_Position startPos, LexAccessor &styler) noexcept {
+	do {
+		const unsigned char ch = styler.SafeGetCharAt(startPos);
+		if (!IsWhiteSpace(ch)) {
+			return ch;
+		}
+		++startPos;
+	} while (true);
+}
+
+inline unsigned char LexGetNextChar(Sci_Position startPos, Sci_Position endPos, LexAccessor &styler) noexcept {
+	while (startPos < endPos) {
+		const unsigned char ch = styler[startPos];
+		if (!IsWhiteSpace(ch)) {
+			return ch;
+		}
+		++startPos;
+	}
+	return '\0';
+}
+
+
+inline int PackLineState(const std::vector<int>& states) noexcept {
+	return PackLineState<DefaultNestedStateValueBit, DefaultMaxNestedStateCount, DefaultNestedStateCountBit, DefaultNestedStateBaseStyle>(states);
+}
+
+inline void UnpackLineState(int lineState, std::vector<int>& states) {
+	UnpackLineState<DefaultNestedStateValueBit, DefaultMaxNestedStateCount, DefaultNestedStateCountBit, DefaultNestedStateBaseStyle>(lineState, states);
+}
+
+inline void BacktrackToStart(const LexAccessor &styler, int stateMask, Sci_PositionU &startPos, Sci_Position &lengthDoc, int &initStyle) noexcept {
+	const auto currentLine = styler.GetLine(startPos);
+	if (currentLine != 0) {
+		auto line = currentLine - 1;
+		int lineState = styler.GetLineState(line);
+		while ((lineState & stateMask) != 0 && line != 0) {
+			--line;
+			lineState = styler.GetLineState(line);
+		}
+		if ((lineState & stateMask) == 0) {
+			++line;
+		}
+		if (line != currentLine) {
+			const Sci_Position endPos = startPos + lengthDoc;
+			startPos = (line == 0)? 0 : styler.LineStart(line);
+			lengthDoc = endPos - startPos;
+			initStyle = (startPos == 0)? 0 : styler.StyleAt(startPos - 1);
+		}
+	}
+}
+
+inline void LookbackNonWhite(LexAccessor &styler, Sci_PositionU startPos, int maxSpaceStyle, int &chPrevNonWhite, int &stylePrevNonWhite) noexcept {
+	Sci_PositionU back = startPos - 1;
+	while (back) {
+		const int style = styler.StyleAt(back);
+		if (style > maxSpaceStyle) {
+			chPrevNonWhite = static_cast<unsigned char>(styler.SafeGetCharAt(back));
+			stylePrevNonWhite = style;
+			break;
+		}
+		--back;
+	}
+}
+
+inline Sci_PositionU CheckBraceOnNextLine(LexAccessor &styler, unsigned int line, int operatorStyle, int maxSpaceStyle, int ignoreStyle = 0) noexcept {
+	// check brace on next line
+	Sci_Position startPos = styler.LineStart(line + 1);
+	Sci_Position bracePos = startPos;
+	char ch;
+	while (IsASpaceOrTab(ch = styler[bracePos])) {
+		++bracePos;
+	}
+	if (ch != '{') {
+		return 0;
+	}
+
+	int style = styler.StyleAt(bracePos);
+	if (style != operatorStyle) {
+		return 0;
+	}
+
+	// check current line
+	Sci_Position endPos = startPos - 1;
+	startPos = styler.LineStart(line);
+
+	// ignore current line, e.g. current line is preprocessor.
+	if (ignoreStyle) {
+		while (startPos < endPos) {
+			style = styler.StyleAt(startPos);
+			if (style > maxSpaceStyle) {
+				break;
+			}
+			++startPos;
+		}
+		if (style == ignoreStyle) {
+			return 0;
+		}
+	}
+
+	while (endPos >= startPos) {
+		style = styler.StyleAt(endPos);
+		if (style > maxSpaceStyle) {
+			break;
+		}
+		--endPos;
+	}
+	if (endPos < startPos) {
+		// current line is empty or comment
+		return 0;
+	}
+	if (style == operatorStyle) {
+		ch = styler[endPos];
+		/*
+		function(param)
+			{ body }
+
+		if (expr)
+			{ body }
+		else
+			{ body }
+
+		switch (expr)
+			{ body }
+
+		class name<T>
+			{ body }
+
+		var name =
+			{ body }
+		var name = new type[]
+			{ body }
+
+		case constant:
+			{ body }
+
+		ActionScript:
+			function name(param:*):*
+				{ body }
+		C++:
+			[lambda-capture]
+				{ body }
+		C#:
+			=> { lambda }
+		Java:
+			-> { lambda }
+		Objective-C:
+			^{ block }
+		Rust:
+			fn name() -> optional?
+				{ body }
+		Scala:
+			class name[T]
+				{ body }
+		*/
+		if (!AnyOf(ch, ')', '>', '=', ':', ']', '^', '?', '*')) {
+			return 0;
+		}
+	}
+
+	/*
+		class name
+			{ body }
+
+		try
+			{ body }
+		catch (exception)
+			{ body }
+	*/
+	return bracePos;
+}
+
 }
 
 #endif
diff --git a/lexlib/LexerModule.h b/lexlib/LexerModule.h
index 6b548481..17fd8a39 100644
--- a/lexlib/LexerModule.h
+++ b/lexlib/LexerModule.h
@@ -14,6 +14,8 @@ class Accessor;
 class WordList;
 struct LexicalClass;
 
+typedef WordList * LexerWordList[];
+
 typedef void (*LexerFunction)(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle,
                   WordList *keywordlists[], Accessor &styler);
 typedef Scintilla::ILexer5 *(*LexerFactoryFunction)();
@@ -71,6 +73,12 @@ inline int Maximum(int a, int b) noexcept {
 	return (a > b) ? a : b;
 }
 
+constexpr int SCE_SIMPLE_OPERATOR = 5;
+constexpr int SimpleLineStateMaskLineComment = 1;
+
+// code folding for braces, brackets, parentheses and consecutive line comments.
+void FoldSimpleDoc(Sci_PositionU startPos, Sci_Position lengthDoc, int /*initStyle*/, LexerWordList /*keywordLists*/, Accessor &styler);
+
 // Shut up annoying Visual C++ warnings:
 #ifdef _MSC_VER
 #pragma warning(disable: 4244 4456 4457)
diff --git a/lexlib/StyleContext.cxx b/lexlib/StyleContext.cxx
index ca564ec4..1897d4d2 100644
--- a/lexlib/StyleContext.cxx
+++ b/lexlib/StyleContext.cxx
@@ -7,6 +7,8 @@
 
 #include <cstdlib>
 #include <cassert>
+#include <cstdint>
+#include <cstring>
 
 #include "ILexer.h"
 
@@ -14,6 +16,7 @@
 #include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
+#include "StringUtils.h"
 
 using namespace Lexilla;
 
@@ -66,3 +69,54 @@ static void getRangeLowered(Sci_PositionU start,
 void StyleContext::GetCurrentLowered(char *s, Sci_PositionU len) {
 	getRangeLowered(styler.GetStartSegment(), currentPos - 1, styler, s, len);
 }
+
+namespace Lexilla {
+
+namespace {
+
+constexpr bool IsTaskMarkerPrev(int chPrev) noexcept {
+	return chPrev <= 32 || AnyOf(chPrev, '/', '*', '!', '#');
+}
+
+constexpr bool IsTaskMarkerStart(int visibleChars, int visibleCharsBefore, int chPrev, int ch, int chNext) noexcept {
+	return (visibleChars == 0 || (visibleChars <= visibleCharsBefore + 3 && IsTaskMarkerPrev(chPrev)))
+		&& IsUpperCase(ch) && IsUpperCase(chNext);
+}
+
+}
+
+bool HighlightTaskMarker(StyleContext &sc, int &visibleChars, int visibleCharsBefore, int markerStyle) {
+	if (IsTaskMarkerStart(visibleChars, visibleCharsBefore, sc.chPrev, sc.ch, sc.chNext)) {
+		Sci_PositionU pos = sc.currentPos + 2;
+		unsigned char ch;
+		while (IsUpperCase(ch = sc.styler[pos])) {
+			++pos;
+		}
+
+		bool marker = false;
+		const int len = static_cast<int>(pos - sc.currentPos);
+		if (ch == ':' || ch == '(') {
+			// highlight first uppercase word after comment characters as task marker.
+			marker = true;
+		} else if (ch <= 32 && len >= 3 && len < 16 && AnyOf(sc.ch, 'T', 'F', 'N', 'X')) {
+			char s[8];
+			sc.styler.GetRange(sc.currentPos, pos, s, sizeof(s));
+			marker = StrEqualsAny(s, "TODO", "FIXME", "NOTE", "XXX", "TBD")
+				|| StrStartsWith(s, "NOLINT"); // clang-tidy: NOLINT, NOLINTNEXTLINE
+		}
+
+		visibleChars += len;
+		const int state = sc.state;
+		sc.SetState(markerStyle);
+		sc.Forward(len);
+		if (marker) {
+			sc.SetState(state);
+		} else {
+			sc.ChangeState(state);
+		}
+		return true;
+	}
+	return false;
+}
+
+}
\ No newline at end of file
diff --git a/lexlib/StyleContext.h b/lexlib/StyleContext.h
index a03c74cd..dbff8161 100644
--- a/lexlib/StyleContext.h
+++ b/lexlib/StyleContext.h
@@ -15,7 +15,9 @@ namespace Lexilla {
 // DBCS treated specially as the second character can be < 0x80 and hence
 // syntactically significant. UTF-8 avoids this as all trail bytes are >= 0x80
 class StyleContext {
+public:
 	LexAccessor &styler;
+private:
 	Scintilla::IDocument *multiByteAccess;
 	Sci_PositionU endPos;
 	Sci_PositionU lengthDocument;
@@ -185,6 +187,18 @@ public:
 	bool Match(char ch0, char ch1) const {
 		return (ch == static_cast<unsigned char>(ch0)) && (chNext == static_cast<unsigned char>(ch1));
 	}
+	bool Match(char ch0, char ch1, char ch2) const noexcept {
+		return Match(ch0, ch1) && ch2 == styler.SafeGetCharAt(currentPos + 2);
+	}
+	bool Match(char ch0, char ch1, char ch2, char ch3) const noexcept {
+		return Match(ch0, ch1, ch2) && ch3 == styler.SafeGetCharAt(currentPos + 3);
+	}
+	bool MatchNext(char ch0, char ch1) const noexcept {
+		return chNext == static_cast<unsigned char>(ch0) && ch1 == styler.SafeGetCharAt(currentPos + 2);
+	}
+	bool MatchNext(char ch0, char ch1, char ch2) const noexcept {
+		return MatchNext(ch0, ch1) && ch2 == styler.SafeGetCharAt(currentPos + 3);
+	}
 	bool Match(const char *s) {
 		if (ch != static_cast<unsigned char>(*s))
 			return false;
@@ -201,12 +215,35 @@ public:
 		}
 		return true;
 	}
+	int GetDocNextChar(bool ignoreCurrent = false) const noexcept {
+		if (!ignoreCurrent && !IsWhiteSpace(ch)) {
+			return ch;
+		}
+		if (!IsWhiteSpace(chNext)) {
+			return chNext;
+		}
+		return LexGetNextChar(currentPos + 2, styler);
+	}
+	int GetLineNextChar(bool ignoreCurrent = false) const noexcept {
+		if (!ignoreCurrent && !IsWhiteSpace(ch)) {
+			return ch;
+		}
+		if (currentPos + 1 == lineStartNext) {
+			return '\0';
+		}
+		if (!IsWhiteSpace(chNext)) {
+			return chNext;
+		}
+		return LexGetNextChar(currentPos + 2, lineStartNext, styler);
+	}
 	// Non-inline
 	bool MatchIgnoreCase(const char *s);
 	void GetCurrent(char *s, Sci_PositionU len);
 	void GetCurrentLowered(char *s, Sci_PositionU len);
 };
 
+bool HighlightTaskMarker(StyleContext &sc, int &visibleChars, int visibleCharsBefore, int markerStyle);
+
 }
 
 #endif
diff --git a/lexlib/WordList.cxx b/lexlib/WordList.cxx
index 4676717a..bcf799c6 100644
--- a/lexlib/WordList.cxx
+++ b/lexlib/WordList.cxx
@@ -15,6 +15,7 @@
 #include "WordList.h"
 
 using namespace Lexilla;
+using range_t = WordList::range_t;
 
 /**
  * Creates an array that points into each word in the string and puts \0 terminators
@@ -60,6 +61,26 @@ static char **ArrayFromWordList(char *wordlist, size_t slen, int *len, bool only
 	return keywords;
 }
 
+/** Threshold for linear search.
+ * Because of cache locality and other metrics, linear search is faster than binary search
+ * when word list contains few words.
+ */
+constexpr range_t WordListLinearSearchThreshold = 5;
+
+// words in [start, end) starts with same character, maximum word count limited to 0xffff.
+struct Range {
+	range_t start;
+	const range_t end;
+	explicit constexpr Range(range_t range) noexcept : start(range & 0xffff), end(range >> 16) {}
+	constexpr range_t Length() const noexcept {
+		return end - start;
+	}
+	bool Next() noexcept {
+		++start;
+		return start < end;
+	}
+};
+
 WordList::WordList(bool onlyLineEnds_) :
 	words(0), list(0), len(0), onlyLineEnds(onlyLineEnds_) {
 	// Prevent warnings by static analyzers about uninitialized starts.
@@ -197,6 +218,78 @@ bool WordList::InList(const char *s) const noexcept {
 	return false;
 }
 
+/**
+ * similar to InList, but word s can be a prefix of keyword.
+ * mainly used to test whether a function is built-in or not.
+ * e.g. for keyword definition "sin(x)", InListPrefixed("sin", '(') => true
+ * InList(s) == InListPrefixed(s, '\0')
+ */
+bool WordList::InListPrefixed(const char *s, const char marker) const noexcept {
+	if (nullptr == words) {
+		return false;
+	}
+	const unsigned char firstChar = s[0];
+	if (firstChar & 0x80) {
+		return false;
+	}
+	range_t end = ranges[firstChar];
+	if (end) {
+		Range range(end);
+		range_t count = range.Length();
+		if (count < WordListLinearSearchThreshold) {
+			do {
+				const char *a = words[range.start] + 1;
+				const char *b = s + 1;
+				while (*a && *a == *b) {
+					a++;
+					b++;
+				}
+				if ((!*a || *a == marker) && !*b) {
+					return true;
+				}
+			} while (range.Next());
+		} else {
+			do {
+				const range_t step = count >> 1;
+				const range_t mid = range.start + step;
+				const char *a = words[mid] + 1;
+				const char *b = s + 1;
+				while (*a && *a == *b) {
+					a++;
+					b++;
+				}
+				const int diff = static_cast<unsigned char>(*a) - static_cast<unsigned char>(*b);
+				if (diff == 0 || diff == static_cast<unsigned char>(marker)) {
+					return true;
+				}
+				if (diff < 0) {
+					range.start = mid + 1;
+					count -= step + 1;
+				} else {
+					count = step;
+				}
+			} while (count != 0);
+		}
+	}
+
+	end = ranges[static_cast<unsigned char>('^')];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start] + 1;
+			const char *b = s;
+			while (*a && *a == *b) {
+				a++;
+				b++;
+			}
+			if (!*a) {
+				return true;
+			}
+		} while (range.Next());
+	}
+	return false;
+}
+
 /** similar to InList, but word s can be a substring of keyword.
  * eg. the keyword define is defined as def~ine. This means the word must start
  * with def to be a keyword, but also defi, defin and define are valid.
diff --git a/lexlib/WordList.h b/lexlib/WordList.h
index 07ae573b..3ea71fa2 100644
--- a/lexlib/WordList.h
+++ b/lexlib/WordList.h
@@ -13,10 +13,14 @@ namespace Lexilla {
 /**
  */
 class WordList {
+public:
+	using range_t = unsigned int;
+private:
 	// Each word contains at least one character - a empty word acts as sentinel at the end.
 	char **words;
 	char *list;
 	int len;
+	range_t ranges[128];	// only ASCII, most word starts with character in '_a-zA-Z'
 	bool onlyLineEnds;	///< Delimited by any white space or only line ends
 	int starts[256];
 public:
@@ -28,6 +32,7 @@ public:
 	void Clear() noexcept;
 	bool Set(const char *s);
 	bool InList(const char *s) const noexcept;
+	bool InListPrefixed(const char *s, char marker) const noexcept;
 	bool InListAbbreviated(const char *s, const char marker) const noexcept;
 	bool InListAbridged(const char *s, const char marker) const noexcept;
 	const char *WordAt(int n) const noexcept;
diff --git a/src/Lexilla.cxx b/src/Lexilla.cxx
index cd4b2361..9bea5b6b 100644
--- a/src/Lexilla.cxx
+++ b/src/Lexilla.cxx
@@ -158,7 +158,10 @@ extern LexerModule lmVisualProlog;
 extern LexerModule lmX12;
 extern LexerModule lmXML;
 extern LexerModule lmYAML;
-
+extern LexerModule lmLLVM;
+extern LexerModule lmSwift;
+extern LexerModule lmKotlin;
+extern LexerModule lmWASM;
 //--Autogenerated -- end of automatically generated section
 
 namespace {
@@ -304,6 +307,10 @@ void AddEachLexer() {
 		&lmX12,
 		&lmXML,
 		&lmYAML,
+		&lmLLVM,
+		&lmKotlin,
+		&lmSwift,
+		&lmWASM,
 
 //--Autogenerated -- end of automatically generated section
 		});
