diff --git a/include/SciLexer.h b/include/SciLexer.h
index 618534fa..78d8345e 100644
--- a/include/SciLexer.h
+++ b/include/SciLexer.h
@@ -146,6 +146,10 @@
 #define SCLEX_RAKU 131
 #define SCLEX_FSHARP 132
 #define SCLEX_JULIA 133
+#define SCLEX_LLVM 209
+#define SCLEX_KOTLIN 210
+#define SCLEX_WASM 213
+#define SCLEX_SWIFT 218
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -2000,6 +2004,100 @@
 #define SCE_FSHARP_QUOTATION 17
 #define SCE_FSHARP_ATTRIBUTE 18
 #define SCE_FSHARP_FORMAT_SPEC 19
+#define SCE_KOTLIN_DEFAULT 0
+#define SCE_KOTLIN_COMMENTLINE 1
+#define SCE_KOTLIN_COMMENTLINEDOC 2
+#define SCE_KOTLIN_COMMENTBLOCK 3
+#define SCE_KOTLIN_COMMENTBLOCKDOC 4
+#define SCE_KOTLIN_COMMENTDOCWORD 5
+#define SCE_KOTLIN_TASKMARKER 6
+#define SCE_KOTLIN_NUMBER 7
+#define SCE_KOTLIN_OPERATOR 8
+#define SCE_KOTLIN_OPERATOR2 9
+#define SCE_KOTLIN_CHARACTER 10
+#define SCE_KOTLIN_STRING 11
+#define SCE_KOTLIN_RAWSTRING 12
+#define SCE_KOTLIN_ESCAPECHAR 13
+#define SCE_KOTLIN_RAWSTRINGSTART 14
+#define SCE_KOTLIN_RAWSTRINGEND 15
+#define SCE_KOTLIN_BACKTICKS 16
+#define SCE_KOTLIN_VARIABLE 17
+#define SCE_KOTLIN_ANNOTATION 18
+#define SCE_KOTLIN_LABEL 19
+#define SCE_KOTLIN_IDENTIFIER 20
+#define SCE_KOTLIN_WORD 21
+#define SCE_KOTLIN_CLASS 22
+#define SCE_KOTLIN_INTERFACE 23
+#define SCE_KOTLIN_ENUM 24
+#define SCE_KOTLIN_FUNCTION 25
+#define SCE_LLVM_DEFAULT 0
+#define SCE_LLVM_COMMENTLINE 1
+#define SCE_LLVM_TASKMARKER 2
+#define SCE_LLVM_NUMBER 3
+#define SCE_LLVM_IDENTIFIER 4
+#define SCE_LLVM_OPERATOR 5
+#define SCE_LLVM_STRING 6
+#define SCE_LLVM_ESCAPECHAR 7
+#define SCE_LLVM_COMDAT 8
+#define SCE_LLVM_METADATA 9
+#define SCE_LLVM_META_STRING 10
+#define SCE_LLVM_ATTRIBUTE_GROUP 11
+#define SCE_LLVM_VARIABLE 12
+#define SCE_LLVM_GLOBAL_VARIABLE 13
+#define SCE_LLVM_QUOTED_VARIABLE 14
+#define SCE_LLVM_QUOTED_GLOBAL_VARIABLE 15
+#define SCE_LLVM_ATTRIBUTE 16
+#define SCE_LLVM_INSTRUCTION 17
+#define SCE_LLVM_INTRINSIC 18
+#define SCE_LLVM_FUNCTION 19
+#define SCE_LLVM_WORD 20
+#define SCE_LLVM_WORD2 21
+#define SCE_LLVM_TYPE 22
+#define SCE_LLVM_LABEL 23
+#define SCE_WASM_DEFAULT 0
+#define SCE_WASM_COMMENTLINE 1
+#define SCE_WASM_COMMENTBLOCK 2
+#define SCE_WASM_TASKMARKER 3
+#define SCE_WASM_NUMBER 4
+#define SCE_WASM_OPERATOR 5
+#define SCE_WASM_IDENTIFIER 6
+#define SCE_WASM_STRING 7
+#define SCE_WASM_ESCAPECHAR 8
+#define SCE_WASM_INSTRUCTION 9
+#define SCE_WASM_WORD 10
+#define SCE_WASM_KEYWORD 11
+#define SCE_WASM_TYPE 12
+#define SCE_SWIFT_DEFAULT 0
+#define SCE_SWIFT_COMMENTLINE 1
+#define SCE_SWIFT_COMMENTLINEDOC 2
+#define SCE_SWIFT_COMMENTBLOCK 3
+#define SCE_SWIFT_COMMENTBLOCKDOC 4
+#define SCE_SWIFT_TASKMARKER 5
+#define SCE_SWIFT_NUMBER 6
+#define SCE_SWIFT_OPERATOR 7
+#define SCE_SWIFT_OPERATOR2 8
+#define SCE_SWIFT_FUNCTION 9
+#define SCE_SWIFT_LABEL 10
+#define SCE_SWIFT_STRING 11
+#define SCE_SWIFT_TRIPLE_STRING 12
+#define SCE_SWIFT_STRING_ED 13
+#define SCE_SWIFT_TRIPLE_STRING_ED 14
+#define SCE_SWIFT_ESCAPECHAR 15
+#define SCE_SWIFT_TRIPLE_STRINGSTART 16
+#define SCE_SWIFT_TRIPLE_STRING_EDSTART 17
+#define SCE_SWIFT_TRIPLE_STRINGEND 18
+#define SCE_SWIFT_TRIPLE_STRING_EDEND 19
+#define SCE_SWIFT_DIRECTIVE 20
+#define SCE_SWIFT_IDENTIFIER 21
+#define SCE_SWIFT_IDENTIFIER_BT 22
+#define SCE_SWIFT_ATTRIBUTE 23
+#define SCE_SWIFT_VARIABLE 24
+#define SCE_SWIFT_WORD 25
+#define SCE_SWIFT_CLASS 26
+#define SCE_SWIFT_STRUCT 27
+#define SCE_SWIFT_PROTOCOL 28
+#define SCE_SWIFT_ENUM 29
+#define SCE_SWIFT_FUNCTION_DEFINE 30
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff --git a/lexers/LexA68k.cxx b/lexers/LexA68k.cxx
index eb22ca10..b5a78635 100644
--- a/lexers/LexA68k.cxx
+++ b/lexers/LexA68k.cxx
@@ -34,31 +34,6 @@ using namespace Lexilla;
 #define OPERATOR_1CHAR  1
 #define OPERATOR_2CHAR  2
 
-
-/**
- *  IsIdentifierStart
- *
- *  Return true if the given char is a valid identifier first char
- */
-
-static inline bool IsIdentifierStart (const int ch)
-{
-    return (isalpha(ch) || (ch == '_') || (ch == '\\'));
-}
-
-
-/**
- *  IsIdentifierChar
- *
- *  Return true if the given char is a valid identifier char
- */
-
-static inline bool IsIdentifierChar (const int ch)
-{
-    return (isalnum(ch) || (ch == '_') || (ch == '@') || (ch == ':') || (ch == '.'));
-}
-
-
 /**
  *  GetOperatorType
  *
diff --git a/lexers/LexBasic.cxx b/lexers/LexBasic.cxx
index 7839271a..2995651a 100644
--- a/lexers/LexBasic.cxx
+++ b/lexers/LexBasic.cxx
@@ -79,10 +79,6 @@ static bool IsDigit(int c) {
 	return c < 128 && (character_classification[c] & 8);
 }
 
-static bool IsHexDigit(int c) {
-	return c < 128 && (character_classification[c] & 16);
-}
-
 static bool IsBinDigit(int c) {
 	return c < 128 && (character_classification[c] & 32);
 }
diff --git a/lexers/LexHollywood.cxx b/lexers/LexHollywood.cxx
index 2cf22d6d..e6760df9 100644
--- a/lexers/LexHollywood.cxx
+++ b/lexers/LexHollywood.cxx
@@ -197,10 +197,6 @@ static bool IsDigit(int c) {
 	return c < 128 && (character_classification[c] & 8);
 }
 
-static bool IsHexDigit(int c) {
-	return c < 128 && (character_classification[c] & 16);
-}
-
 static int LowerCase(int c)
 {
 	if (c >= 'A' && c <= 'Z')
diff --git a/lexers/LexMagik.cxx b/lexers/LexMagik.cxx
index 3fda8f16..a9a2b5bf 100644
--- a/lexers/LexMagik.cxx
+++ b/lexers/LexMagik.cxx
@@ -36,16 +36,6 @@ static inline bool IsAlphaCore(int ch) {
     return (isalpha(ch) || ch == '!' || ch == '?');
 }
 
-/**
- * Is it a character (IsAlphaCore() and underscore)
- *
- * \param  ch The character
- * \return True if ch is a character, False otherwise
- */
-static inline bool IsAlpha(int ch) {
-    return (IsAlphaCore(ch) || ch == '_');
-}
-
 /**
  * Is it a symbolic character (IsAlpha() and colon)
  *
diff --git a/lexers/LexOScript.cxx b/lexers/LexOScript.cxx
index 98c6b23a..92bee5f9 100644
--- a/lexers/LexOScript.cxx
+++ b/lexers/LexOScript.cxx
@@ -31,24 +31,6 @@ using namespace Lexilla;
 // -----------------------------------------
 // Functions classifying a single character.
 
-// This function is generic and should be probably moved to CharSet.h where
-// IsAlphaNumeric the others reside.
-inline bool IsAlpha(int ch) {
-	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
-}
-
-static inline bool IsIdentifierChar(int ch) {
-	// Identifiers cannot contain non-ASCII letters; a word with non-English
-	// language-specific characters cannot be an identifier.
-	return IsAlphaNumeric(ch) || ch == '_';
-}
-
-static inline bool IsIdentifierStart(int ch) {
-	// Identifiers cannot contain non-ASCII letters; a word with non-English
-	// language-specific characters cannot be an identifier.
-	return IsAlpha(ch) || ch == '_';
-}
-
 static inline bool IsNumberChar(int ch, int chNext) {
 	// Numeric constructs are not checked for lexical correctness. They are
 	// expected to look like +1.23-E9 but actually any bunch of the following
diff --git a/lexers/LexR.cxx b/lexers/LexR.cxx
index 8f2849a1..b1f75be2 100644
--- a/lexers/LexR.cxx
+++ b/lexers/LexR.cxx
@@ -12,6 +12,7 @@
 #include <stdarg.h>
 #include <assert.h>
 #include <ctype.h>
+#include <algorithm>
 
 #include "ILexer.h"
 #include "Scintilla.h"
@@ -210,5 +211,64 @@ static const char * const RWordLists[] = {
         };
 
 
+constexpr int GetLineCommentState(int lineState) noexcept {
+	return lineState & SimpleLineStateMaskLineComment;
+}
+
+namespace Lexilla {
+
+void FoldSimpleDoc(Sci_PositionU startPos, Sci_Position lengthDoc, int /*initStyle*/, LexerWordList /*keywordLists*/, Accessor &styler) {
+	const Sci_PositionU endPos = startPos + lengthDoc;
+	auto lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	int lineCommentPrev = 0;
+	if (lineCurrent > 0) {
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+		lineCommentPrev = GetLineCommentState(styler.GetLineState(lineCurrent - 1));
+	}
+
+	int levelNext = levelCurrent;
+	int lineCommentCurrent = GetLineCommentState(styler.GetLineState(lineCurrent));
+	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
+	Sci_PositionU lineEndPos = std::min(lineStartNext, endPos) - 1;
+
+	for (Sci_PositionU i = startPos; i < endPos; i++) {
+		const int style = styler.StyleAt(i);
+
+		if (style == SCE_SIMPLE_OPERATOR) {
+			const char ch = styler[i];
+			if (ch == '{' || ch == '[' || ch == '(') {
+				levelNext++;
+			} else if (ch == '}' || ch == ']' || ch == ')') {
+				levelNext--;
+			}
+		}
+
+		if (i == lineEndPos) {
+			const int lineCommentNext = GetLineCommentState(styler.GetLineState(lineCurrent + 1));
+			if (lineCommentCurrent) {
+				levelNext += lineCommentNext - lineCommentPrev;
+			}
+
+			const int levelUse = levelCurrent;
+			int lev = levelUse | levelNext << 16;
+			if (levelUse < levelNext) {
+				lev |= SC_FOLDLEVELHEADERFLAG;
+			}
+			if (lev != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, lev);
+			}
+
+			lineCurrent++;
+			lineStartNext = styler.LineStart(lineCurrent + 1);
+			lineEndPos = std::min(lineStartNext, endPos) - 1;
+			levelCurrent = levelNext;
+			lineCommentPrev = lineCommentCurrent;
+			lineCommentCurrent = lineCommentNext;
+		}
+	}
+}
+
+}
 
 LexerModule lmR(SCLEX_R, ColouriseRDoc, "r", FoldRDoc, RWordLists);
diff --git a/lexers/LexRust.cxx b/lexers/LexRust.cxx
index 402a4730..20e5c838 100644
--- a/lexers/LexRust.cxx
+++ b/lexers/LexRust.cxx
@@ -184,11 +184,6 @@ static bool IsWhitespace(int c) {
     return c == ' ' || c == '\t' || c == '\r' || c == '\n';
 }
 
-/* This isn't quite right for Unicode identifiers */
-static bool IsIdentifierStart(int ch) {
-	return (IsASCII(ch) && (isalpha(ch) || ch == '_')) || !IsASCII(ch);
-}
-
 /* This isn't quite right for Unicode identifiers */
 static bool IsIdentifierContinue(int ch) {
 	return (IsASCII(ch) && (isalnum(ch) || ch == '_')) || !IsASCII(ch);
diff --git a/lexlib/CharacterSet.h b/lexlib/CharacterSet.h
index 50eedb7c..134e213a 100644
--- a/lexlib/CharacterSet.h
+++ b/lexlib/CharacterSet.h
@@ -65,8 +65,30 @@ public:
 
 using CharacterSet = CharacterSetArray<0x80>;
 
+template <typename T, typename... Args>
+constexpr bool AnyOf(T t, Args... args) noexcept {
+#if defined(__clang__)
+	static_assert(__is_integral(T));
+#endif
+	return ((t == args) || ...);
+}
+
+// prevent pointer without <type_traits>
+template <typename T, typename... Args>
+constexpr void AnyOf([[maybe_unused]] T *t, [[maybe_unused]] Args... args) noexcept {}
+template <typename T, typename... Args>
+constexpr void AnyOf([[maybe_unused]] const T *t, [[maybe_unused]] Args... args) noexcept {}
+
+constexpr bool Between(int value, int lower, int high) noexcept {
+	return value >= lower && value <= high;
+}
+
 // Functions for classifying characters
 
+constexpr bool IsEOLChar(int ch) noexcept {
+	return ch == '\r' || ch == '\n';
+}
+
 constexpr bool IsASpace(int ch) noexcept {
     return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
 }
@@ -76,17 +98,43 @@ constexpr bool IsASpaceOrTab(int ch) noexcept {
 }
 
 constexpr bool IsADigit(int ch) noexcept {
-	return (ch >= '0') && (ch <= '9');
+	return ch >= '0' && ch <= '9';
+}
+
+constexpr bool IsHexDigit(int ch) noexcept {
+	return (ch >= '0' && ch <= '9')
+		|| (ch >= 'A' && ch <= 'F')
+		|| (ch >= 'a' && ch <= 'f');
+}
+
+constexpr bool IsOctalDigit(int ch) noexcept {
+	return ch >= '0' && ch <= '7';
 }
 
 constexpr bool IsADigit(int ch, int base) noexcept {
 	if (base <= 10) {
-		return (ch >= '0') && (ch < '0' + base);
-	} else {
-		return ((ch >= '0') && (ch <= '9')) ||
-		       ((ch >= 'A') && (ch < 'A' + base - 10)) ||
-		       ((ch >= 'a') && (ch < 'a' + base - 10));
+		return (ch >= '0' && ch < '0' + base);
 	}
+	return (ch >= '0' && ch <= '9')
+		|| Between(ch | 0x20, 'a', 'a' + base - 10);
+}
+
+constexpr bool IsNumberStart(int ch, int chNext) noexcept {
+	return IsADigit(ch) || (ch == '.' && IsADigit(chNext));
+}
+
+constexpr bool IsNumberStartEx(int chPrev, int ch, int chNext) noexcept {
+	return IsADigit(ch) || (chPrev != '.' && ch == '.' && IsADigit(chNext));
+}
+
+constexpr bool IsNumberContinue(int chPrev, int ch, int chNext) noexcept {
+	return ((ch == '+' || ch == '-') && (chPrev == 'e' || chPrev == 'E'))
+		|| (ch == '.' && chNext != '.');
+}
+
+constexpr bool IsNumberContinueEx(int chPrev, int ch, int chNext) noexcept {
+	return ((ch == '+' || ch == '-') && (chPrev == 'e' || chPrev == 'E' || chPrev == 'p' || chPrev == 'P'))
+		|| (ch == '.' && chNext != '.');
 }
 
 constexpr bool IsASCII(int ch) noexcept {
@@ -105,6 +153,11 @@ constexpr bool IsUpperOrLowerCase(int ch) noexcept {
 	return IsUpperCase(ch) || IsLowerCase(ch);
 }
 
+constexpr bool IsAlpha(int ch) noexcept {
+	return (ch >= 'a' && ch <= 'z')
+		|| (ch >= 'A' && ch <= 'Z');
+}
+
 constexpr bool IsAlphaNumeric(int ch) noexcept {
 	return
 		((ch >= '0') && (ch <= '9')) ||
@@ -128,6 +181,34 @@ constexpr bool iswordstart(int ch) noexcept {
 	return IsAlphaNumeric(ch) || ch == '_';
 }
 
+constexpr bool IsIdentifierChar(int ch) noexcept {
+	return IsAlphaNumeric(ch) || ch == '_';
+}
+
+constexpr bool IsIdentifierStart(int ch) noexcept {
+	return IsAlpha(ch) || ch == '_';
+}
+
+constexpr bool IsDecimalNumber(int chPrev, int ch, int chNext) noexcept {
+	return IsIdentifierChar(ch) || IsNumberContinue(chPrev, ch, chNext);
+}
+
+constexpr bool IsDecimalNumberEx(int chPrev, int ch, int chNext) noexcept {
+	return IsIdentifierChar(ch) || IsNumberContinueEx(chPrev, ch, chNext);
+}
+
+// simply treat every character/byte larger than 127 as Unicode identifier,
+// i.e. we don't support Unicode operators. proper implementation will need
+// enable multiByteAccess in StyleContext and use functions from CharacterCategory.
+
+constexpr bool IsIdentifierCharEx(int ch) noexcept {
+	return IsIdentifierChar(ch) || ch >= 0x80;
+}
+
+constexpr bool IsIdentifierStartEx(int ch) noexcept {
+	return IsIdentifierStart(ch) || ch >= 0x80;
+}
+
 constexpr bool isoperator(int ch) noexcept {
 	if (IsAlphaNumeric(ch))
 		return false;
@@ -140,6 +221,45 @@ constexpr bool isoperator(int ch) noexcept {
 		return true;
 	return false;
 }
+// isoperator() excludes following eight punctuation: '"', '#', '$', '\'', '@', '\\', '_', '`'
+// in most lexers, isoperator(ch) is equivalent to following code:
+// IsAGraphic(ch) && !AnyOf(ch, '#', '$', '@', '\\', '`');
+
+constexpr bool IsAGraphic(int ch) noexcept {
+	// excludes C0 control characters and whitespace
+	return ch > 32 && ch < 127;
+}
+
+constexpr bool IsGraphic(int ch) noexcept {
+	// excludes C0 control characters and whitespace
+	return ch > 32 && ch != 127;
+}
+
+constexpr bool IsPunctuation(int ch) noexcept {
+	//return IsAGraphic(ch) && !IsAlphaNumeric(ch);
+	return (ch > 32 && ch < '0')
+		|| (ch > '9' && ch < 'A')
+		|| (ch > 'Z' && ch < 'a')
+		|| (ch > 'z' && ch < 127);
+}
+
+constexpr bool IsCommentTagPrev(int chPrev) noexcept {
+	return chPrev <= 32 || AnyOf(chPrev, '/', '*', '!');
+}
+
+constexpr bool IsInvalidUrlChar(int ch) noexcept {
+	return ch <= 32 || ch >= 127
+		|| AnyOf(ch, '"', '<', '>', '\\', '^', '`', '{', '|', '}');
+}
+
+// characters can follow jump `label:`, based on Swift's document Labeled Statement at
+// https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_labeled-statement
+// good coding style should place left aligned label on it's own line.
+constexpr bool IsJumpLabelNextChar(int chNext) noexcept {
+	// own line, comment, for, foreach, while, do, if, switch, repeat
+	// TODO: match each word exactly like HighlightTaskMarker().
+	return AnyOf(chNext, '\0', '/', 'f', 'w', 'd', 'i', 's', 'r');
+}
 
 // Simple case functions for ASCII supersets.
 
diff --git a/lexlib/LexAccessor.h b/lexlib/LexAccessor.h
index 331c501f..35d4cab6 100644
--- a/lexlib/LexAccessor.h
+++ b/lexlib/LexAccessor.h
@@ -8,6 +8,12 @@
 #ifndef LEXACCESSOR_H
 #define LEXACCESSOR_H
 
+#include <cstring>
+#include <algorithm>
+#include "StringUtils.h"
+#include "CharacterSet.h"
+#include "LexerUtils.h"
+
 namespace Lexilla {
 
 enum class EncodingType { eightBit, unicode, dbcs };
@@ -181,6 +187,22 @@ public:
 	void ChangeLexerState(Sci_Position start, Sci_Position end) {
 		pAccess->ChangeLexerState(start, end);
 	}
+
+	void GetRange(Sci_PositionU startPos_, Sci_PositionU endPos_, char *s, Sci_PositionU len) noexcept {
+		endPos_ = std::min(endPos_, startPos_ + len - 1);
+		if (startPos_ >= static_cast<Sci_PositionU>(startPos) && endPos_ <= static_cast<Sci_PositionU>(endPos)) {
+			const char *p = buf + (startPos_ - startPos);
+			const char * const t = buf + (endPos_ - startPos);
+			while (p < t) {
+				*s++ = *p++;
+			}
+		} else {
+			for (; startPos_ < endPos_; startPos_++) {
+				*s++ = (*this)[startPos_];
+			}
+		}
+		*s = '\0';
+	}
 };
 
 struct LexicalClass {
@@ -190,6 +212,181 @@ struct LexicalClass {
 	const char *description;
 };
 
+constexpr bool IsWhiteSpace(int ch) noexcept {
+	return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
+}
+
+inline unsigned char LexGetNextChar(Sci_Position startPos, LexAccessor &styler) noexcept {
+	do {
+		const unsigned char ch = styler[startPos];
+		if (!IsWhiteSpace(ch)) {
+			return ch;
+		}
+		++startPos;
+	} while (true);
+}
+
+inline unsigned char LexGetNextChar(Sci_Position startPos, Sci_Position endPos, LexAccessor &styler) noexcept {
+	while (startPos < endPos) {
+		const unsigned char ch = styler[startPos];
+		if (!IsWhiteSpace(ch)) {
+			return ch;
+		}
+		++startPos;
+	}
+	return '\0';
+}
+
+
+inline int PackLineState(const std::vector<int>& states) noexcept {
+	return PackLineState<DefaultNestedStateValueBit, DefaultMaxNestedStateCount, DefaultNestedStateCountBit, DefaultNestedStateBaseStyle>(states);
+}
+
+inline void UnpackLineState(int lineState, std::vector<int>& states) {
+	UnpackLineState<DefaultNestedStateValueBit, DefaultMaxNestedStateCount, DefaultNestedStateCountBit, DefaultNestedStateBaseStyle>(lineState, states);
+}
+
+inline void BacktrackToStart(const LexAccessor &styler, int stateMask, Sci_PositionU &startPos, Sci_Position &lengthDoc, int &initStyle) noexcept {
+	const auto currentLine = styler.GetLine(startPos);
+	if (currentLine != 0) {
+		auto line = currentLine - 1;
+		int lineState = styler.GetLineState(line);
+		while ((lineState & stateMask) != 0 && line != 0) {
+			--line;
+			lineState = styler.GetLineState(line);
+		}
+		if ((lineState & stateMask) == 0) {
+			++line;
+		}
+		if (line != currentLine) {
+			const Sci_Position endPos = startPos + lengthDoc;
+			startPos = (line == 0)? 0 : styler.LineStart(line);
+			lengthDoc = endPos - startPos;
+			initStyle = (startPos == 0)? 0 : styler.StyleAt(startPos - 1);
+		}
+	}
+}
+
+inline void LookbackNonWhite(LexAccessor &styler, Sci_PositionU startPos, int maxSpaceStyle, int &chPrevNonWhite, int &stylePrevNonWhite) noexcept {
+	Sci_PositionU back = startPos - 1;
+	while (back) {
+		const int style = styler.StyleAt(back);
+		if (style > maxSpaceStyle) {
+			chPrevNonWhite = static_cast<unsigned char>(styler.SafeGetCharAt(back));
+			stylePrevNonWhite = style;
+			break;
+		}
+		--back;
+	}
+}
+
+inline Sci_PositionU CheckBraceOnNextLine(LexAccessor &styler, unsigned int line, int operatorStyle, int maxSpaceStyle, int ignoreStyle = 0) noexcept {
+	// check brace on next line
+	Sci_Position startPos = styler.LineStart(line + 1);
+	Sci_Position bracePos = startPos;
+	char ch;
+	while (IsASpaceOrTab(ch = styler[bracePos])) {
+		++bracePos;
+	}
+	if (ch != '{') {
+		return 0;
+	}
+
+	int style = styler.StyleAt(bracePos);
+	if (style != operatorStyle) {
+		return 0;
+	}
+
+	// check current line
+	Sci_Position endPos = startPos - 1;
+	startPos = styler.LineStart(line);
+
+	// ignore current line, e.g. current line is preprocessor.
+	if (ignoreStyle) {
+		while (startPos < endPos) {
+			style = styler.StyleAt(startPos);
+			if (style > maxSpaceStyle) {
+				break;
+			}
+			++startPos;
+		}
+		if (style == ignoreStyle) {
+			return 0;
+		}
+	}
+
+	while (endPos >= startPos) {
+		style = styler.StyleAt(endPos);
+		if (style > maxSpaceStyle) {
+			break;
+		}
+		--endPos;
+	}
+	if (endPos < startPos) {
+		// current line is empty or comment
+		return 0;
+	}
+	if (style == operatorStyle) {
+		ch = styler[endPos];
+		/*
+		function(param)
+			{ body }
+
+		if (expr)
+			{ body }
+		else
+			{ body }
+
+		switch (expr)
+			{ body }
+
+		class name<T>
+			{ body }
+
+		var name =
+			{ body }
+		var name = new type[]
+			{ body }
+
+		case constant:
+			{ body }
+
+		ActionScript:
+			function name(param:*):*
+				{ body }
+		C++:
+			[lambda-capture]
+				{ body }
+		C#:
+			=> { lambda }
+		Java:
+			-> { lambda }
+		Objective-C:
+			^{ block }
+		Rust:
+			fn name() -> optional?
+				{ body }
+		Scala:
+			class name[T]
+				{ body }
+		*/
+		if (!AnyOf(ch, ')', '>', '=', ':', ']', '^', '?', '*')) {
+			return 0;
+		}
+	}
+
+	/*
+		class name
+			{ body }
+
+		try
+			{ body }
+		catch (exception)
+			{ body }
+	*/
+	return bracePos;
+}
+
 }
 
 #endif
diff --git a/lexlib/LexerBase.cxx b/lexlib/LexerBase.cxx
index eb4466fe..15a5e8c4 100644
--- a/lexlib/LexerBase.cxx
+++ b/lexlib/LexerBase.cxx
@@ -64,7 +64,7 @@ const char * SCI_METHOD LexerBase::DescribeProperty(const char *) {
 Sci_Position SCI_METHOD LexerBase::PropertySet(const char *key, const char *val) {
 	const char *valOld = props.Get(key);
 	if (strcmp(val, valOld) != 0) {
-		props.Set(key, val);
+		props.Set(key, val, strlen(key), strlen(val));
 		return 0;
 	} else {
 		return -1;
diff --git a/lexlib/LexerModule.h b/lexlib/LexerModule.h
index d6ab78fc..f4ef28c1 100644
--- a/lexlib/LexerModule.h
+++ b/lexlib/LexerModule.h
@@ -14,6 +14,8 @@ class Accessor;
 class WordList;
 struct LexicalClass;
 
+typedef WordList * LexerWordList[];
+
 typedef void (*LexerFunction)(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle,
                   WordList *keywordlists[], Accessor &styler);
 typedef Scintilla::ILexer5 *(*LexerFactoryFunction)();
@@ -71,6 +73,12 @@ constexpr int Maximum(int a, int b) noexcept {
 	return (a > b) ? a : b;
 }
 
+constexpr int SCE_SIMPLE_OPERATOR = 5;
+constexpr int SimpleLineStateMaskLineComment = 1;
+
+// code folding for braces, brackets, parentheses and consecutive line comments.
+void FoldSimpleDoc(Sci_PositionU startPos, Sci_Position lengthDoc, int /*initStyle*/, LexerWordList /*keywordLists*/, Accessor &styler);
+
 // Shut up annoying Visual C++ warnings:
 #ifdef _MSC_VER
 #pragma warning(disable: 4244 4456 4457)
diff --git a/lexlib/PropSetSimple.cxx b/lexlib/PropSetSimple.cxx
index 09e36bc6..102f56a5 100644
--- a/lexlib/PropSetSimple.cxx
+++ b/lexlib/PropSetSimple.cxx
@@ -26,6 +26,10 @@ mapss *PropsFromPointer(void *impl) noexcept {
 	return static_cast<mapss *>(impl);
 }
 
+constexpr bool IsASpaceCharacter(int ch) noexcept {
+	return (ch == ' ') || ((ch >= 0x09) && (ch <= 0x0d));
+}
+
 }
 
 PropSetSimple::PropSetSimple() {
@@ -39,26 +43,114 @@ PropSetSimple::~PropSetSimple() {
 	impl = nullptr;
 }
 
-void PropSetSimple::Set(std::string_view key, std::string_view val) {
+void PropSetSimple::Set(const char *key, const char *val, size_t lenKey, size_t lenVal) {
 	mapss *props = PropsFromPointer(impl);
-	if (!props)
+	if (!*key)	// Empty keys are not supported
 		return;
-	(*props)[std::string(key)] = std::string(val);
+	(*props)[std::string(key, lenKey)] = std::string(val, lenVal);
+}
+
+void PropSetSimple::Set(const char *keyVal) {
+	while (IsASpaceCharacter(*keyVal))
+		keyVal++;
+	const char *endVal = keyVal;
+	while (*endVal && (*endVal != '\n'))
+		endVal++;
+	const char *eqAt = strchr(keyVal, '=');
+	if (eqAt) {
+		Set(keyVal, eqAt + 1, eqAt-keyVal,
+			endVal - eqAt - 1);
+	} else if (*keyVal) {	// No '=' so assume '=1'
+		Set(keyVal, "1", endVal-keyVal, 1);
+	}
+}
+
+void PropSetSimple::SetMultiple(const char *s) {
+	const char *eol = strchr(s, '\n');
+	while (eol) {
+		Set(s);
+		s = eol + 1;
+		eol = strchr(s, '\n');
+	}
+	Set(s);
 }
 
 const char *PropSetSimple::Get(const char *key) const {
 	mapss *props = PropsFromPointer(impl);
-	if (props) {
-		mapss::const_iterator keyPos = props->find(std::string(key));
-		if (keyPos != props->end()) {
-			return keyPos->second.c_str();
+	mapss::const_iterator keyPos = props->find(std::string(key));
+	if (keyPos != props->end()) {
+		return keyPos->second.c_str();
+	} else {
+		return "";
+	}
+}
+
+// There is some inconsistency between GetExpanded("foo") and Expand("$(foo)").
+// A solution is to keep a stack of variables that have been expanded, so that
+// recursive expansions can be skipped.  For now I'll just use the C++ stack
+// for that, through a recursive function and a simple chain of pointers.
+
+struct VarChain {
+	VarChain(const char *var_=nullptr, const VarChain *link_= nullptr) noexcept : var(var_), link(link_) {}
+
+	bool contains(const char *testVar) const {
+		return (var && (0 == strcmp(var, testVar)))
+			|| (link && link->contains(testVar));
+	}
+
+	const char *var;
+	const VarChain *link;
+};
+
+static int ExpandAllInPlace(const PropSetSimple &props, std::string &withVars, int maxExpands, const VarChain &blankVars) {
+	size_t varStart = withVars.find("$(");
+	while ((varStart != std::string::npos) && (maxExpands > 0)) {
+		const size_t varEnd = withVars.find(')', varStart+2);
+		if (varEnd == std::string::npos) {
+			break;
+		}
+
+		// For consistency, when we see '$(ab$(cde))', expand the inner variable first,
+		// regardless whether there is actually a degenerate variable named 'ab$(cde'.
+		size_t innerVarStart = withVars.find("$(", varStart+2);
+		while ((innerVarStart != std::string::npos) && (innerVarStart > varStart) && (innerVarStart < varEnd)) {
+			varStart = innerVarStart;
+			innerVarStart = withVars.find("$(", varStart+2);
+		}
+
+		std::string var(withVars, varStart + 2, varEnd - varStart - 2);
+		std::string val = props.Get(var.c_str());
+
+		if (blankVars.contains(var.c_str())) {
+			val = ""; // treat blankVar as an empty string (e.g. to block self-reference)
+		}
+
+		if (--maxExpands >= 0) {
+			maxExpands = ExpandAllInPlace(props, val, maxExpands, VarChain(var.c_str(), &blankVars));
 		}
+
+		withVars.erase(varStart, varEnd-varStart+1);
+		withVars.insert(varStart, val.c_str(), val.length());
+
+		varStart = withVars.find("$(");
+	}
+
+	return maxExpands;
+}
+
+size_t PropSetSimple::GetExpanded(const char *key, char *result) const {
+	std::string val = Get(key);
+	ExpandAllInPlace(*this, val, 100, VarChain(key));
+	const size_t n = val.size();
+	if (result) {
+		memcpy(result, val.c_str(), n+1);
 	}
-	return "";
+	return n;	// Not including NUL
 }
 
 int PropSetSimple::GetInt(const char *key, int defaultValue) const {
 	std::string val = Get(key);
+	ExpandAllInPlace(*this, val, 100, VarChain(key));
 	if (!val.empty()) {
 		return atoi(val.c_str());
 	}
diff --git a/lexlib/PropSetSimple.h b/lexlib/PropSetSimple.h
index 0cc610e6..110411c4 100644
--- a/lexlib/PropSetSimple.h
+++ b/lexlib/PropSetSimple.h
@@ -12,16 +12,14 @@ namespace Lexilla {
 
 class PropSetSimple {
 	void *impl;
+	void Set(const char *keyVal);
 public:
 	PropSetSimple();
-	// Deleted so PropSetSimple objects can not be copied.
-	PropSetSimple(const PropSetSimple&) = delete;
-	PropSetSimple(PropSetSimple&&) = delete;
-	PropSetSimple &operator=(const PropSetSimple&) = delete;
-	PropSetSimple &operator=(PropSetSimple&&) = delete;
 	virtual ~PropSetSimple();
-	void Set(std::string_view key, std::string_view val);
+	void Set(const char *key, const char *val, size_t lenKey, size_t lenVal);
+	void SetMultiple(const char *);
 	const char *Get(const char *key) const;
+	size_t GetExpanded(const char *key, char *result) const;
 	int GetInt(const char *key, int defaultValue=0) const;
 };
 
diff --git a/lexlib/StyleContext.cxx b/lexlib/StyleContext.cxx
index ca564ec4..bcad18ca 100644
--- a/lexlib/StyleContext.cxx
+++ b/lexlib/StyleContext.cxx
@@ -7,6 +7,8 @@
 
 #include <cstdlib>
 #include <cassert>
+#include <cstdint>
+#include <cstring>
 
 #include "ILexer.h"
 
@@ -14,6 +16,7 @@
 #include "Accessor.h"
 #include "StyleContext.h"
 #include "CharacterSet.h"
+#include "StringUtils.h"
 
 using namespace Lexilla;
 
@@ -66,3 +69,54 @@ static void getRangeLowered(Sci_PositionU start,
 void StyleContext::GetCurrentLowered(char *s, Sci_PositionU len) {
 	getRangeLowered(styler.GetStartSegment(), currentPos - 1, styler, s, len);
 }
+
+namespace Lexilla {
+
+namespace {
+
+constexpr bool IsTaskMarkerPrev(int chPrev) noexcept {
+	return chPrev <= 32 || AnyOf(chPrev, '/', '*', '!', '#');
+}
+
+constexpr bool IsTaskMarkerStart(int visibleChars, int visibleCharsBefore, int chPrev, int ch, int chNext) noexcept {
+	return (visibleChars == 0 || (visibleChars <= visibleCharsBefore + 3 && IsTaskMarkerPrev(chPrev)))
+		&& IsUpperCase(ch) && IsUpperCase(chNext);
+}
+
+}
+
+bool HighlightTaskMarker(StyleContext &sc, int &visibleChars, int visibleCharsBefore, int markerStyle) {
+	if (IsTaskMarkerStart(visibleChars, visibleCharsBefore, sc.chPrev, sc.ch, sc.chNext)) {
+		Sci_PositionU pos = sc.currentPos + 2;
+		unsigned char ch;
+		while (IsUpperCase(ch = sc.styler[pos])) {
+			++pos;
+		}
+
+		bool marker = false;
+		const int len = static_cast<int>(pos - sc.currentPos);
+		if (ch == ':' || ch == '(') {
+			// highlight first uppercase word after comment characters as task marker.
+			marker = true;
+		} else if (ch <= 32 && len >= 3 && len < 16 && AnyOf(sc.ch, 'T', 'F', 'N', 'X')) {
+			char s[8];
+			sc.styler.GetRange(sc.currentPos, pos, s, sizeof(s));
+			marker = StrEqualsAny(s, "TODO", "FIXME", "NOTE", "XXX", "TBD")
+				|| StrStartsWith(s, "NOLINT"); // clang-tidy: NOLINT, NOLINTNEXTLINE
+		}
+
+		visibleChars += len;
+		const int state = sc.state;
+		sc.SetState(markerStyle);
+		sc.Forward(len);
+		if (marker) {
+			sc.SetState(state);
+		} else {
+			sc.ChangeState(state);
+		}
+		return true;
+	}
+	return false;
+}
+
+}
\ No newline at end of file
diff --git a/lexlib/StyleContext.h b/lexlib/StyleContext.h
index a6c6f9f4..0e0ba0a9 100644
--- a/lexlib/StyleContext.h
+++ b/lexlib/StyleContext.h
@@ -15,7 +15,9 @@ namespace Lexilla {
 // DBCS treated specially as the second character can be < 0x80 and hence
 // syntactically significant. UTF-8 avoids this as all trail bytes are >= 0x80
 class StyleContext {
+public:
 	LexAccessor &styler;
+private:
 	Scintilla::IDocument *multiByteAccess;
 	Sci_PositionU endPos;
 	Sci_PositionU lengthDocument;
@@ -192,6 +194,18 @@ public:
 	bool Match(char ch0, char ch1) const {
 		return (ch == static_cast<unsigned char>(ch0)) && (chNext == static_cast<unsigned char>(ch1));
 	}
+	bool Match(char ch0, char ch1, char ch2) const noexcept {
+		return Match(ch0, ch1) && ch2 == styler.SafeGetCharAt(currentPos + 2);
+	}
+	bool Match(char ch0, char ch1, char ch2, char ch3) const noexcept {
+		return Match(ch0, ch1, ch2) && ch3 == styler.SafeGetCharAt(currentPos + 3);
+	}
+	bool MatchNext(char ch0, char ch1) const noexcept {
+		return chNext == static_cast<unsigned char>(ch0) && ch1 == styler.SafeGetCharAt(currentPos + 2);
+	}
+	bool MatchNext(char ch0, char ch1, char ch2) const noexcept {
+		return MatchNext(ch0, ch1) && ch2 == styler.SafeGetCharAt(currentPos + 3);
+	}
 	bool Match(const char *s) {
 		if (ch != static_cast<unsigned char>(*s))
 			return false;
@@ -208,12 +222,35 @@ public:
 		}
 		return true;
 	}
+	int GetDocNextChar(bool ignoreCurrent = false) const noexcept {
+		if (!ignoreCurrent && !IsWhiteSpace(ch)) {
+			return ch;
+		}
+		if (!IsWhiteSpace(chNext)) {
+			return chNext;
+		}
+		return LexGetNextChar(currentPos + 2, styler);
+	}
+	int GetLineNextChar(bool ignoreCurrent = false) const noexcept {
+		if (!ignoreCurrent && !IsWhiteSpace(ch)) {
+			return ch;
+		}
+		if (currentPos + 1 == lineStartNext) {
+			return '\0';
+		}
+		if (!IsWhiteSpace(chNext)) {
+			return chNext;
+		}
+		return LexGetNextChar(currentPos + 2, lineStartNext, styler);
+	}
 	// Non-inline
 	bool MatchIgnoreCase(const char *s);
 	void GetCurrent(char *s, Sci_PositionU len);
 	void GetCurrentLowered(char *s, Sci_PositionU len);
 };
 
+bool HighlightTaskMarker(StyleContext &sc, int &visibleChars, int visibleCharsBefore, int markerStyle);
+
 }
 
 #endif
diff --git a/lexlib/WordList.cxx b/lexlib/WordList.cxx
index 4676717a..9715420d 100644
--- a/lexlib/WordList.cxx
+++ b/lexlib/WordList.cxx
@@ -15,55 +15,83 @@
 #include "WordList.h"
 
 using namespace Lexilla;
+using range_t = WordList::range_t;
+
+namespace {
 
 /**
  * Creates an array that points into each word in the string and puts \0 terminators
  * after each word.
  */
-static char **ArrayFromWordList(char *wordlist, size_t slen, int *len, bool onlyLineEnds = false) {
-	int prev = '\n';
-	int words = 0;
-	// For rapid determination of whether a character is a separator, build
-	// a look up table.
-	bool wordSeparator[256] = {};	// Initialise all to false.
-	wordSeparator[static_cast<unsigned int>('\r')] = true;
-	wordSeparator[static_cast<unsigned int>('\n')] = true;
-	if (!onlyLineEnds) {
-		wordSeparator[static_cast<unsigned int>(' ')] = true;
-		wordSeparator[static_cast<unsigned int>('\t')] = true;
-	}
-	for (int j = 0; wordlist[j]; j++) {
-		const int curr = static_cast<unsigned char>(wordlist[j]);
-		if (!wordSeparator[curr] && wordSeparator[prev])
+inline char **ArrayFromWordList(char *wordlist, size_t slen, range_t *len) {
+	unsigned char prev = 1;
+	range_t words = 0;
+	// treat space and C0 control characters as word separators.
+
+	char * const end = wordlist + slen;
+	char *s = wordlist;
+	while (s < end) {
+		const unsigned char ch = *s++;
+		const bool curr = ch <= ' ';
+		if (!curr && prev) {
 			words++;
+		}
 		prev = curr;
 	}
+
 	char **keywords = new char *[words + 1];
-	int wordsStore = 0;
+	range_t wordsStore = 0;
 	if (words) {
 		prev = '\0';
-		for (size_t k = 0; k < slen; k++) {
-			if (!wordSeparator[static_cast<unsigned char>(wordlist[k])]) {
+		s = wordlist;
+		while (s < end) {
+			unsigned char ch = *s;
+			if (ch > ' ') {
 				if (!prev) {
-					keywords[wordsStore] = &wordlist[k];
+					keywords[wordsStore] = s;
 					wordsStore++;
 				}
 			} else {
-				wordlist[k] = '\0';
+				*s = '\0';
+				ch = '\0';
 			}
-			prev = wordlist[k];
+			prev = ch;
+			++s;
 		}
 	}
+
 	assert(wordsStore < (words + 1));
-	keywords[wordsStore] = &wordlist[slen];
+	keywords[wordsStore] = end;
 	*len = wordsStore;
 	return keywords;
 }
 
-WordList::WordList(bool onlyLineEnds_) :
-	words(0), list(0), len(0), onlyLineEnds(onlyLineEnds_) {
-	// Prevent warnings by static analyzers about uninitialized starts.
-	starts[0] = -1;
+/** Threshold for linear search.
+ * Because of cache locality and other metrics, linear search is faster than binary search
+ * when word list contains few words.
+ */
+constexpr range_t WordListLinearSearchThreshold = 5;
+
+// words in [start, end) starts with same character, maximum word count limited to 0xffff.
+struct Range {
+	range_t start;
+	const range_t end;
+	explicit constexpr Range(range_t range) noexcept : start(range & 0xffff), end(range >> 16) {}
+	constexpr range_t Length() const noexcept {
+		return end - start;
+	}
+	bool Next() noexcept {
+		++start;
+		return start < end;
+	}
+};
+
+}
+
+WordList::WordList() noexcept :
+	words(nullptr), list(nullptr), len(0) {
+	// Prevent warnings by static analyzers about uninitialized ranges.
+	ranges[0] = {};
 }
 
 WordList::~WordList() {
@@ -71,86 +99,67 @@ WordList::~WordList() {
 }
 
 WordList::operator bool() const noexcept {
-	return len ? true : false;
+	return len != 0;
 }
 
 bool WordList::operator!=(const WordList &other) const noexcept {
-	if (len != other.len)
+	if (len != other.len) {
 		return true;
-	for (int i=0; i<len; i++) {
-		if (strcmp(words[i], other.words[i]) != 0)
+	}
+	for (range_t i = 0; i < len; i++) {
+		if (strcmp(words[i], other.words[i]) != 0) {
 			return true;
+		}
 	}
 	return false;
 }
 
-int WordList::Length() const noexcept {
+range_t WordList::Length() const noexcept {
 	return len;
 }
 
 void WordList::Clear() noexcept {
 	if (words) {
-		delete []list;
-		delete []words;
+		delete[]list;
+		delete[]words;
 	}
 	words = nullptr;
 	list = nullptr;
 	len = 0;
 }
 
-#ifdef _MSC_VER
-
-static bool cmpWords(const char *a, const char *b) {
-	return strcmp(a, b) < 0;
-}
-
-#else
+bool WordList::Set(const char *s, bool toLower) {
+	// omitted comparison for Notepad2, we don't care whether the list is same as before or not.
+	// 1. when we call SciCall_SetKeywords(), the document or styles already changed.
+	// 2. the comparison is expensive than rebuild the list, especially for a long list.
 
-static int cmpWords(const void *a, const void *b) {
-	return strcmp(*static_cast<const char * const *>(a), *static_cast<const char * const *>(b));
-}
-
-static void SortWordList(char **words, unsigned int len) {
-	qsort(words, len, sizeof(*words), cmpWords);
-}
-
-#endif
-
-bool WordList::Set(const char *s) {
+	Clear();
 	const size_t lenS = strlen(s) + 1;
-	char *listTemp = new char[lenS];
-	memcpy(listTemp, s, lenS);
-	int lenTemp = 0;
-	char **wordsTemp = ArrayFromWordList(listTemp, lenS - 1, &lenTemp, onlyLineEnds);
-#ifdef _MSC_VER
-	std::sort(wordsTemp, wordsTemp + lenTemp, cmpWords);
-#else
-	SortWordList(wordsTemp, lenTemp);
-#endif
-
-	if (lenTemp == len) {
-		bool changed = false;
-		for (int i = 0; i < lenTemp; i++) {
-			if (strcmp(words[i], wordsTemp[i]) != 0) {
-				changed = true;
-				break;
+	list = new char[lenS];
+	memcpy(list, s, lenS);
+	if (toLower) {
+		char *p = list;
+		while (*p) {
+			if (*p >= 'A' && *p <= 'Z') {
+				*p += 'a' - 'A';
 			}
-		}
-		if (!changed) {
-			delete []listTemp;
-			delete []wordsTemp;
-			return false;
+			++p;
 		}
 	}
 
-	Clear();
-	words = wordsTemp;
-	list = listTemp;
-	len = lenTemp;
-	std::fill(starts, std::end(starts), -1);
-	for (int l = len - 1; l >= 0; l--) {
-		unsigned char indexChar = words[l][0];
-		starts[indexChar] = l;
+	words = ArrayFromWordList(list, lenS - 1, &len);
+	std::sort(words, words + len, [](const char *a, const char *b) noexcept {
+		return strcmp(a, b) < 0;
+	});
+
+	memset(ranges, 0, sizeof(ranges));
+	for (range_t i = 0; i < len;) {
+		const unsigned char indexChar = *words[i];
+		const range_t start = i++;
+		while (static_cast<unsigned char>(*words[i]) == indexChar) {
+			++i;
+		}
+		ranges[indexChar] = start | (i << 16);
 	}
 	return true;
 }
@@ -161,39 +170,140 @@ bool WordList::Set(const char *s) {
  * so '^GTK_' matches 'GTK_X', 'GTK_MAJOR_VERSION', and 'GTK_'.
  */
 bool WordList::InList(const char *s) const noexcept {
-	if (0 == words)
+	if (nullptr == words) {
 		return false;
+	}
 	const unsigned char firstChar = s[0];
-	int j = starts[firstChar];
-	if (j >= 0) {
-		while (words[j][0] == firstChar) {
-			if (s[1] == words[j][1]) {
-				const char *a = words[j] + 1;
+	if (firstChar & 0x80) {
+		return false;
+	}
+	range_t end = ranges[firstChar];
+	if (end) {
+		Range range(end);
+		range_t count = range.Length();
+		if (count < WordListLinearSearchThreshold) {
+			do {
+				const char *a = words[range.start] + 1;
 				const char *b = s + 1;
 				while (*a && *a == *b) {
 					a++;
 					b++;
 				}
-				if (!*a && !*b)
+				if (!*a && !*b) {
 					return true;
-			}
-			j++;
+				}
+			} while (range.Next());
+		} else {
+			do {
+				const range_t step = count >> 1;
+				const range_t mid = range.start + step;
+				const char *a = words[mid] + 1;
+				const char *b = s + 1;
+				while (*a && *a == *b) {
+					a++;
+					b++;
+				}
+				const int diff = static_cast<unsigned char>(*a) - static_cast<unsigned char>(*b);
+				if (diff == 0) {
+					return true;
+				}
+				if (diff < 0) {
+					range.start = mid + 1;
+					count -= step + 1;
+				} else {
+					count = step;
+				}
+			} while (count != 0);
 		}
 	}
-	j = starts[static_cast<unsigned int>('^')];
-	if (j >= 0) {
-		while (words[j][0] == '^') {
-			const char *a = words[j] + 1;
+
+	end = ranges[static_cast<unsigned char>('^')];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start] + 1;
 			const char *b = s;
 			while (*a && *a == *b) {
 				a++;
 				b++;
 			}
-			if (!*a)
+			if (!*a) {
 				return true;
-			j++;
+			}
+		} while (range.Next());
+	}
+	return false;
+}
+
+/**
+ * similar to InList, but word s can be a prefix of keyword.
+ * mainly used to test whether a function is built-in or not.
+ * e.g. for keyword definition "sin(x)", InListPrefixed("sin", '(') => true
+ * InList(s) == InListPrefixed(s, '\0')
+ */
+bool WordList::InListPrefixed(const char *s, const char marker) const noexcept {
+	if (nullptr == words) {
+		return false;
+	}
+	const unsigned char firstChar = s[0];
+	if (firstChar & 0x80) {
+		return false;
+	}
+	range_t end = ranges[firstChar];
+	if (end) {
+		Range range(end);
+		range_t count = range.Length();
+		if (count < WordListLinearSearchThreshold) {
+			do {
+				const char *a = words[range.start] + 1;
+				const char *b = s + 1;
+				while (*a && *a == *b) {
+					a++;
+					b++;
+				}
+				if ((!*a || *a == marker) && !*b) {
+					return true;
+				}
+			} while (range.Next());
+		} else {
+			do {
+				const range_t step = count >> 1;
+				const range_t mid = range.start + step;
+				const char *a = words[mid] + 1;
+				const char *b = s + 1;
+				while (*a && *a == *b) {
+					a++;
+					b++;
+				}
+				const int diff = static_cast<unsigned char>(*a) - static_cast<unsigned char>(*b);
+				if (diff == 0 || diff == static_cast<unsigned char>(marker)) {
+					return true;
+				}
+				if (diff < 0) {
+					range.start = mid + 1;
+					count -= step + 1;
+				} else {
+					count = step;
+				}
+			} while (count != 0);
 		}
 	}
+
+	end = ranges[static_cast<unsigned char>('^')];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start] + 1;
+			const char *b = s;
+			while (*a && *a == *b) {
+				a++;
+				b++;
+			}
+			if (!*a) {
+				return true;
+			}
+		} while (range.Next());
+	}
 	return false;
 }
 
@@ -203,48 +313,52 @@ bool WordList::InList(const char *s) const noexcept {
  * The marker is ~ in this case.
  */
 bool WordList::InListAbbreviated(const char *s, const char marker) const noexcept {
-	if (0 == words)
+	if (nullptr == words) {
 		return false;
+	}
 	const unsigned char firstChar = s[0];
-	int j = starts[firstChar];
-	if (j >= 0) {
-		while (words[j][0] == firstChar) {
+	if (firstChar & 0x80) {
+		return false;
+	}
+	range_t end = ranges[firstChar];
+	if (end) {
+		Range range(end);
+		do {
 			bool isSubword = false;
-			int start = 1;
-			if (words[j][1] == marker) {
+			const char *a = words[range.start] + 1;
+			const char *b = s + 1;
+			if (*a == marker) {
 				isSubword = true;
-				start++;
+				a++;
 			}
-			if (s[1] == words[j][start]) {
-				const char *a = words[j] + start;
-				const char *b = s + 1;
-				while (*a && *a == *b) {
+			while (*a && *a == *b) {
+				a++;
+				if (*a == marker) {
+					isSubword = true;
 					a++;
-					if (*a == marker) {
-						isSubword = true;
-						a++;
-					}
-					b++;
 				}
-				if ((!*a || isSubword) && !*b)
-					return true;
+				b++;
 			}
-			j++;
-		}
+			if ((!*a || isSubword) && !*b) {
+				return true;
+			}
+		} while (range.Next());
 	}
-	j = starts[static_cast<unsigned int>('^')];
-	if (j >= 0) {
-		while (words[j][0] == '^') {
-			const char *a = words[j] + 1;
+
+	end = ranges[static_cast<unsigned char>('^')];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start] + 1;
 			const char *b = s;
 			while (*a && *a == *b) {
 				a++;
 				b++;
 			}
-			if (!*a)
+			if (!*a) {
 				return true;
-			j++;
-		}
+			}
+		} while (range.Next());
 	}
 	return false;
 }
@@ -257,13 +371,18 @@ bool WordList::InListAbbreviated(const char *s, const char marker) const noexcep
 * No multiple markers check is done and wont work.
 */
 bool WordList::InListAbridged(const char *s, const char marker) const noexcept {
-	if (0 == words)
+	if (nullptr == words) {
 		return false;
+	}
 	const unsigned char firstChar = s[0];
-	int j = starts[firstChar];
-	if (j >= 0) {
-		while (words[j][0] == firstChar) {
-			const char *a = words[j];
+	if (firstChar & 0x80) {
+		return false;
+	}
+	range_t end = ranges[firstChar];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start];
 			const char *b = s;
 			while (*a && *a == *b) {
 				a++;
@@ -271,27 +390,28 @@ bool WordList::InListAbridged(const char *s, const char marker) const noexcept {
 					a++;
 					const size_t suffixLengthA = strlen(a);
 					const size_t suffixLengthB = strlen(b);
-					if (suffixLengthA >= suffixLengthB)
+					if (suffixLengthA >= suffixLengthB) {
 						break;
+					}
 					b = b + suffixLengthB - suffixLengthA - 1;
 				}
 				b++;
 			}
-			if (!*a  && !*b)
+			if (!*a && !*b) {
 				return true;
-			j++;
-		}
+			}
+		} while (range.Next());
 	}
 
-	j = starts[static_cast<unsigned int>(marker)];
-	if (j >= 0) {
-		while (words[j][0] == marker) {
-			const char *a = words[j] + 1;
+	end = ranges[static_cast<unsigned char>(marker)];
+	if (end) {
+		Range range(end);
+		do {
+			const char *a = words[range.start] + 1;
 			const char *b = s;
 			const size_t suffixLengthA = strlen(a);
 			const size_t suffixLengthB = strlen(b);
 			if (suffixLengthA > suffixLengthB) {
-				j++;
 				continue;
 			}
 			b = b + suffixLengthB - suffixLengthA;
@@ -300,16 +420,15 @@ bool WordList::InListAbridged(const char *s, const char marker) const noexcept {
 				a++;
 				b++;
 			}
-			if (!*a && !*b)
+			if (!*a && !*b) {
 				return true;
-			j++;
-		}
+			}
+		} while (range.Next());
 	}
 
 	return false;
 }
 
-const char *WordList::WordAt(int n) const noexcept {
+const char *WordList::WordAt(range_t n) const noexcept {
 	return words[n];
 }
-
diff --git a/lexlib/WordList.h b/lexlib/WordList.h
index 07ae573b..edd27e90 100644
--- a/lexlib/WordList.h
+++ b/lexlib/WordList.h
@@ -4,35 +4,37 @@
  **/
 // Copyright 1998-2010 by Neil Hodgson <neilh@scintilla.org>
 // The License.txt file describes the conditions under which this software may be distributed.
-
-#ifndef WORDLIST_H
-#define WORDLIST_H
+#pragma once
 
 namespace Lexilla {
 
 /**
  */
 class WordList {
+public:
+	using range_t = unsigned int;
+private:
 	// Each word contains at least one character - a empty word acts as sentinel at the end.
 	char **words;
 	char *list;
-	int len;
-	bool onlyLineEnds;	///< Delimited by any white space or only line ends
-	int starts[256];
+	range_t len;
+	range_t ranges[128];	// only ASCII, most word starts with character in '_a-zA-Z'
 public:
-	explicit WordList(bool onlyLineEnds_ = false);
+	explicit WordList() noexcept;
 	~WordList();
 	operator bool() const noexcept;
 	bool operator!=(const WordList &other) const noexcept;
-	int Length() const noexcept;
+	bool operator==(const WordList &other) const noexcept {
+		return !(*this != other);
+	}
+	range_t Length() const noexcept;
 	void Clear() noexcept;
-	bool Set(const char *s);
+	bool Set(const char *s, bool toLower = false);
 	bool InList(const char *s) const noexcept;
-	bool InListAbbreviated(const char *s, const char marker) const noexcept;
-	bool InListAbridged(const char *s, const char marker) const noexcept;
-	const char *WordAt(int n) const noexcept;
+	bool InListPrefixed(const char *s, char marker) const noexcept;
+	bool InListAbbreviated(const char *s, char marker) const noexcept;
+	bool InListAbridged(const char *s, char marker) const noexcept;
+	const char *WordAt(range_t n) const noexcept;
 };
 
 }
-
-#endif
diff --git a/src/Lexilla.cxx b/src/Lexilla.cxx
index cd4b2361..821e0016 100644
--- a/src/Lexilla.cxx
+++ b/src/Lexilla.cxx
@@ -12,7 +12,7 @@
 #include <initializer_list>
 
 #if _WIN32
-#define EXPORT_FUNCTION __declspec(dllexport)
+#define EXPORT_FUNCTION 
 #define CALLING_CONVENTION __stdcall
 #else
 #define EXPORT_FUNCTION __attribute__((visibility("default")))
@@ -158,7 +158,10 @@ extern LexerModule lmVisualProlog;
 extern LexerModule lmX12;
 extern LexerModule lmXML;
 extern LexerModule lmYAML;
-
+extern LexerModule lmLLVM;
+extern LexerModule lmSwift;
+extern LexerModule lmKotlin;
+extern LexerModule lmWASM;
 //--Autogenerated -- end of automatically generated section
 
 namespace {
@@ -304,6 +307,10 @@ void AddEachLexer() {
 		&lmX12,
 		&lmXML,
 		&lmYAML,
+		&lmLLVM,
+		&lmKotlin,
+		&lmSwift,
+		&lmWASM,
 
 //--Autogenerated -- end of automatically generated section
 		});
